##################################################
#file ../shared/componentinterface/datatypes.h
#ifndef DataTypesH
#define DataTypesH
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>

#include <ComponentInterface\MessageData.h>
#include <ComponentInterface\MessageDataExt.h>
#include <ComponentInterface\Type.h>
#include <ComponentInterface\Interfaces.h>

namespace protocol {

//-------------------- Built in types
#for_each type
#define type.nameTypeDDML \
type.cddml
#if (type.name <> null)
class Apsimtype.name : public IData
   {
   private:
      type.ckind& value;
   public:
      Apsimtype.name(type.ckind& v) : value(v) { }
	virtual void pack(protocol::MessageData& messageData)
	   {
      messageData << value;
	   }
	virtual void unpack(protocol::MessageData& messageData)
	   {
      messageData >> value;
	   }
	virtual const char* ddml()
	   {
	   return type.cddml;
	   }
   };
#endif
#endfor

#for_each structure
//-------------------- structure.nameType
#define structure.nameTypeDDML \
structure.cddml
struct structure.nameType
   {
   #for_each structure.field
   #if (field.isArrayAndStructure = T)
   std::vector<field.ctypeType> field.name;
   #elseif (field.array = T)
   std::vector<field.ctype> field.name;
   #elseif (field.isStructure = T)
   field.ctypeType field.name;
   #else
   field.ctype field.name;
   #endif
   #endfor
   };
inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const structure.nameType& data)
   {
   #for_each structure.field
   messageData << data.field.name;
   #endfor
   return messageData;
   }
inline protocol::MessageData& operator>>(protocol::MessageData& messageData, structure.nameType& data)
   {
   #for_each structure.field
   messageData >> data.field.name;
   #endfor
   return messageData;
   }
inline unsigned int memorySize(const structure.nameType& data)
   {
   return 0
   #for_each structure.field
      + protocol::memorySize(data.field.name)
   #endfor;
   }
void Initstructure.name(structure.nameType& data, const std::string& xml);
#if (structure.array = T)
void Initstructure.name(std::vector<structure.nameType>& values, const std::string& xml);
#endif

#endfor
} // protocol
#endif

#endfile
##################################################
#file ../shared/componentinterface/datatypes.cpp
#include <boost/lexical_cast.hpp>
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>

#include "DataTypes.h"
#include "Component.h"
#include "FORTRANComponentWrapper.h"
const unsigned max_array_size = 100;

// turn off the warnings about "Functions containing for are not expanded inline.
#pragma warn -inl

extern "C" __declspec(dllexport) void __stdcall publish_null(unsigned* id)
   {
   FortranWrapper::currentInstance->publish(*id, protocol::NoData());
   }

#for_each structure
namespace protocol {
struct Fstructure.nameType
   {
   #for_each structure.field
   #if (field.isArrayAndStructure = T)
   Ffield.ctypeType field.name[max_array_size];
   #elseif (field.array = T)
   field.ctype field.name[max_array_size];
   #elseif (field.isStructure = T)
   Ffield.ctypeType field.name;
   #elseif (field.ctype = std::string)
   char field.name[max_array_size];
   #else
   field.ctype field.name;
   #endif
   #if (field.array = T)
   unsigned num_field.name;
   #endif
   #endfor
   };
inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const Fstructure.nameType& data)
   {
   #for_each structure.field
   #if (field.array = T)
   messageData << data.num_field.name;
   for (unsigned i = 0; i != data.num_field.name; i++)
      messageData << data.field.name[i];
   #elseif (field.ctype = std::string)
   messageData << FString(data.field.name, max_array_size, FORString);
   #else
   messageData << data.field.name;
   #endif
   #endfor
   return messageData;
   }
inline protocol::MessageData& operator>>(protocol::MessageData& messageData, Fstructure.nameType& data)
   {
   #for_each structure.field
   #if (field.array = T)
   messageData >> data.num_field.name;
   for (unsigned i = 0; i != data.num_field.name; i++)
      messageData >> data.field.name[i];
   #elseif (field.ctype = std::string)
   FString field.nameString(data.field.name, max_array_size, FORString);
   FString field.nameAlias;
   messageData >> field.nameAlias;
   field.nameString = field.nameAlias;
   #else
   messageData >> data.field.name;
   #endif
   #endfor
   return messageData;
   }
inline unsigned int memorySize(const Fstructure.nameType& data)
   {
   return 0
   #for_each structure.field
      #if (field.array = T)
      + 4 + data.num_field.name * protocol::memorySize(data.field.name[0])
      #elseif (field.ctype = std::string)
      + protocol::memorySize(FString(data.field.name, max_array_size, FORString))
      #else
      + protocol::memorySize(data.field.name)
      #endif
   #endfor;
   }
void Initstructure.name(structure.nameType& data, const std::string& xml)
   {
   XMLDocument doc(xml, XMLDocument::xmlContents);
   XMLNode::iterator childI = doc.documentElement();
   #for_each structure.field
   childI = std::find_if(doc.documentElement().begin(),
                         doc.documentElement().end(),
                         EqualToName<XMLNode>("field.name"));

   #if (field.isArrayAndStructure = T)
   // Don't know yet
   #elseif (field.array = T)
   StringToContainer<std::vector<field.ctype>, field.ctype> (childI->getValue(), data.field.name);

   #elseif (field.isStructure = T)
   // Don't know yet
   #else
   data.field.name = boost::lexical_cast<field.ctype> (childI->getValue());
   #endif
   #endfor
   }
   #if (structure.array = T)
void Initstructure.name(std::vector<structure.nameType>& values, const std::string& xml)
   {
   XMLDocument doc(xml, XMLDocument::xmlContents);
   for (XMLNode::iterator childI = doc.documentElement().begin();
                          childI != doc.documentElement().end();
                          childI++)
      {
      string childXml = childI->write();
      structure.nameType data;
      Initstructure.name(data, childXml);
      values.push_back(data);
      }
   }
   #endif
}; // namespace protocol
   #if (structure.array = T)
extern "C" __declspec(dllexport) void __stdcall publish_structure.name(unsigned* id, const protocol::Fstructure.nameType data[], unsigned* numValues)
   {
   FortranWrapper::currentInstance->publishArray(*id, data, *numValues);
   }
   #else
extern "C" __declspec(dllexport) void __stdcall publish_structure.name(unsigned* id, const protocol::Fstructure.nameType* data)
   {
   FortranWrapper::currentInstance->publish(*id, *data);
   }
   #endif
   #if (structure.array = T)
extern "C" __declspec(dllexport) void __stdcall unpack_structure.name(protocol::Variant* variant, protocol::Fstructure.nameType data[], unsigned* numValues)
   {
   variant->unpackArray(data, *numValues);
   }
   #else
extern "C" __declspec(dllexport) void __stdcall unpack_structure.name(protocol::Variant* variant, protocol::Fstructure.nameType* data)
   {
   variant->unpack(*data);
   }
   #endif

#endfor

// restore the warnings about "Functions containing for are not expanded inline.
#pragma warn .inl

#endfile
##################################################
#file ../apsim/infra/source/datatypes.f90
module dataTypes
   integer, parameter :: max_array_size = 100

   !-------------------- Built in types
#for_each type
   character(len=*), parameter :: type.nameTypeDDML = &
type.forddml
#endfor


#for_each structure
!-------------------- structure.nameType
   character(len=*), parameter :: structure.nameTypeDDML = &
structure.forddml
   type structure.nameType
      sequence
      #for_each structure.field
      #if (field.isArrayAndStructure = T)
      type(field.forTypeType):: field.name(max_array_size)
      #elseif (field.isStructure = T)
      type(field.forTypeType) :: field.name
      #elseif (field.array = T)
      field.fortype :: field.name(max_array_size)
      #else
      field.fortype :: field.name
      #endif
      #if (field.array = T)
      integer :: num_field.name
      #endif
      #endfor
   end type structure.nameType

#endfor
end module dataTypes
#endfile

##################################################
#file ../apsim/infra/source/datatypesinterface.f90
module dataTypesInterface
   interface

   subroutine publish_null(id)
   use datatypes
   ml_external publish_null
   integer :: id
   end subroutine

   #for_each structure
   #if (structure.array = T)
   subroutine publish_structure.name(id, data, numValues)
   use datatypes
   ml_external publish_structure.name
   integer :: id
   type(structure.nameType) :: data(*)
   integer :: numValues
   end subroutine
   #else
   subroutine publish_structure.name(id, data)
   use datatypes
   ml_external publish_structure.name
   integer :: id
   type(structure.nameType) :: data
   end subroutine
   #endif

   #if (structure.array = T)
   subroutine unpack_structure.name(variant, data, numValues)
   use datatypes
   ml_external unpack_structure.name
   integer :: variant
   type(structure.nameType) :: data(*)
   integer :: numValues
   end subroutine
   #else
   subroutine unpack_structure.name(variant, data)
   use datatypes
   ml_external unpack_structure.name
   integer :: variant
   type(structure.nameType) :: data
   end subroutine
   #endif
   #endfor

   end interface
end module dataTypesInterface

#endfile