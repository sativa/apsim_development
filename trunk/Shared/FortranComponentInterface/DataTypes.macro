[file FORScienceAPI.f90]
!---------------------------------------------
! Interface for FORTRAN modules.
! Autogenerated - do not modify manually
!---------------------------------------------
module ScienceAPI

   interface
      subroutine Write(Msg)
      ml_external Write
      character(len=*), intent(in) :: Msg
      end subroutine

      subroutine Error(Msg, IsFatal)
      ml_external Error
      character(len=*), intent(in) :: Msg
      logical, intent(in) :: IsFatal
      end subroutine

      subroutine Subscribe(name, proc)
      ml_external Subscribe
      character (len=*), intent(in) :: name
      integer, external :: proc
      end subroutine


   end interface
   interface get

      [foreach types.builtin]
      function Get[builtin.name](Name, Units, Optional, Value, [if [builtin.array] = T]ArraySize, NumValues, [endif]Lower, Upper)
         ml_external Get[builtin.name]
         character(len=*), intent(in) :: Name
         character(len=*), intent(in) :: Units
      logical, intent(in) :: Optional
      [if [builtin.array] = T]
         [builtin.fortype], intent(in out)         :: Value(*)
         integer, intent(in) :: ArraySize
         integer, intent(in) :: NumValues
      [else]
         [builtin.fortype], intent(in out)         :: Value
      [endif]
         [builtin.fortype], intent(in)             :: Lower
         [builtin.fortype], intent(in)             :: Upper
         logical :: Get[builtin.name]
      end function

      [endfor]

   end interface

   interface Read

      [foreach types.builtin]
      function Read[builtin.name](Name, Optional, Value[if [builtin.array] = T], ArraySize, NumValues[endif])
         ml_external Read[builtin.name]
         character(len=*), intent(in) :: Name
         logical, intent(in) :: Optional
      [if [builtin.array] = T]
         [builtin.fortype], intent(in out)         :: Value(*)
         integer, intent(in) :: ArraySize
         integer, intent(in out) :: NumValues
      [else]
         [builtin.fortype], intent(in out)         :: Value
      [endif]
         logical :: Read[builtin.name]
      end function

      [endfor]

   end interface

end module

[endfile]

##################################################
[file FortranComponentInterface.imp]
-implib  "FortranComponentInterface.dll"
-import Write
-import Error
-import Subscribe
[foreach types.builtin]
-import Get[builtin.name]
-import Read[builtin.name]
[endfor]

[endfile]

##################################################
[file FortranScienceAPIImpl.cpp]
//---------------------------------------------
// Interface for FORTRAN modules.
// Autogenerated - do not modify manually
//---------------------------------------------
#include "FortranWrapper.h"
#include <ComponentInterface2/ScienceAPI.h>
using namespace std;

[foreach types.builtin]
// -------------------------------------------------------------------------------------------------
extern "C" bool EXPORT STDCALL Get[builtin.name]
   (const char* Name, const char* Units, int& Optional,
    [if [builtin.ctype] = char*]    char* FortranValue[else]    [builtin.ctype]& Value[endif],
    [if [builtin.array] = T]    int& ArraySize, int& NumValues,[endif]
    [if [builtin.boundable] = T]    [builtin.ctype] Lower, [builtin.ctype] Upper,[endif]
    unsigned NameLength, unsigned UnitsLength[if [builtin.ctype] = char*], unsigned ValueLength[endif])
   {
   [if [builtin.ctype] = char*]   [builtin.cpptype] Value;
   [endif]
   bool ok = FortranWrapper::currentInstance->scienceAPI->get(string(Name, NameLength), string(Units, UnitsLength),
                                                              Optional, Value[if [builtin.boundable] = T], Lower, Upper[endif]);
   [if [builtin.name] = String]
   if (ok)
      {
      ToFortran(Value, FortranValue, ValueLength);
      ok = true;
      }
   [elseif [builtin.name] = StringArray]
   if (ok)
      {
      ToFortran(Value, FortranValue, ValueLength, ArraySize, NumValues);
      ok = true;
      }
   [endif]
   return ok;
   }

// -------------------------------------------------------------------------------------------------
extern "C" bool EXPORT STDCALL Read[builtin.name]
   (const char* Name, const char* Units, int& Optional,
    [if [builtin.ctype] = char*]    char* FortranValue[else]    [builtin.ctype]& Value[endif],
    [if [builtin.array] = T]    int& ArraySize, int& NumValues,[endif]
    [if [builtin.boundable] = T]    [builtin.ctype] Lower, [builtin.ctype] Upper,[endif]

    unsigned NameLength, unsigned UnitsLength[if [builtin.ctype] = char*], unsigned ValueLength[endif])
   {
   [if [builtin.ctype] = char*]   [builtin.cpptype] Value;
   [endif]
   bool ok = FortranWrapper::currentInstance->scienceAPI->read(string(Name, NameLength), string(Units, UnitsLength),
                                                               Optional, Value[if [builtin.boundable] = T], Lower, Upper[endif]);
   [if [builtin.name] = String]
   if (ok)
      {
      ToFortran(Value, FortranValue, ValueLength);
      ok = true;
      }
   [elseif [builtin.name] = StringArray]
   if (ok)
      {
      ToFortran(Value, FortranValue, ValueLength, ArraySize, NumValues);
      ok = true;
      }
   [endif]
   return ok;
   }

[endfor]

[endfile]