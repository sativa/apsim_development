##################################################
[file DataTypes.h]
#ifndef DataTypesH
#define DataTypesH
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include <ComponentInterface2/MessageData.h>
#include <ComponentInterface2/Interfaces.h>

   //------ Null ------
   struct Null
      {
      int i;
      };

   void pack(MessageData& messageData, const Null& data);
   void unpack(MessageData& messageData, Null& data);
   unsigned memorySize(const Null& data);
   std::string DDML(const Null& data);

[foreach types.type]
   //------ [type.name] ------
   struct [type.name]Type
      {
      [foreach type.field]
      [field.cpptype] [field.name];
      [endfor]
      };

   void pack(MessageData& messageData, const [type.name]Type& data);
   void unpack(MessageData& messageData, [type.name]Type& data);
   unsigned memorySize(const [type.name]Type& data);
   std::string DDML(const [type.name]Type& data);

[endfor]
#endif
[endfile]
##################################################
[file DataTypes.cpp]
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include "DataTypes.h"
#include "MessageData.h"
#include "Interfaces.h"

   //------ Null ------
   void pack(MessageData& messageData, const Null& data) { }
   void unpack(MessageData& messageData, Null& data) { }
   unsigned memorySize(const Null& data) {return 0;}
   std::string DDML(const Null& data) {return "<type/>";}


[foreach types.type]
   //------ [type.name] ------

   void pack(MessageData& messageData, const [type.name]Type& data)
      {
      [foreach type.field]
      pack(messageData, data.[field.name]);
      [endfor]
      }
   void unpack(MessageData& messageData, [type.name]Type& data)
      {
      [foreach type.field]
      unpack(messageData, data.[field.name]);
      [endfor]
      }
   unsigned memorySize(const [type.name]Type& data)
      {
      return 0
       [foreach type.field]              + ::memorySize(data.[field.name])
       [endfor]              ;
      }
   std::string DDML(const [type.name]Type& data)
      {return [type.cddml];}

[endfor]
[endfile]

##################################################
[file ScienceAPI.h]
#ifndef ScienceAPIH
#define ScienceAPIH
#include <general/platform.h>
#include <string>
#include <vector>
#include <boost/function.hpp>
#include <boost/bind.hpp>

struct QueryMatch
   {
   std::string name;
   std::string ddml;
   };

// ------------------------------------------------------------------
// Interface for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class ScienceAPI
   {
   public:

      virtual void write(const std::string& msg) = 0;
      virtual std::string name() = 0;
      virtual std::string FQName() = 0;

      // -----------------------------------------------------------------------
      // Return a list of all variables or components (fully qualified)
      // that match the specified pattern.
      // e.g. * will return a list of all components.
      //      wheat.* will return a list of all variables for the wheat module
      //      *.lai will return a list of all lai variables for all modules.
      // -----------------------------------------------------------------------
      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;

      // null
      #define nullFunction(address) boost::function0<void>(boost::bind(address, this))
      virtual void subscribe(const std::string& name, boost::function0<void> handler) = 0;
      virtual void publish(const std::string& name) = 0;

      [foreach types.builtin]
      // [builtin.cpptype]
      #define [builtin.name]Function(address) boost::function1<void, [builtin.cpptype]& >(boost::bind(address, this, _1))
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data) = 0;
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter) = 0;
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler) = 0;
      virtual void publish(const std::string& name, [builtin.cpptype]& data) = 0;

      [endfor]
   };
#endif
[endfile]

##################################################
[file CMPScienceAPI.h]
#ifndef CMPScienceAPIH
#define CMPScienceAPIH
#include <ComponentInterface2/ScienceAPI.h>
#include <general/platform.h>
class CMPComponentInterface;

// ------------------------------------------------------------------
// CMP Implementation for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class EXPORT CMPScienceAPI : public ScienceAPI
   {
   public:
      CMPScienceAPI(CMPComponentInterface& componentinterface);

      virtual void write(const std::string& msg);
      virtual std::string name();
      virtual std::string FQName();

      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches);

      // null
      virtual void subscribe(const std::string& name, boost::function0<void> handler);
      virtual void publish(const std::string& name);

      [foreach types.builtin]
      // [builtin.cpptype]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data);
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> method);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                  boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter);
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler);
      virtual void publish(const std::string& name, [builtin.cpptype]& data);

      [endfor]

   private:
      CMPComponentInterface& componentInterface;
   };
#endif
[endfile]


##################################################
[file CMPScienceAPI.cpp]
#pragma hdrstop

#include "CMPScienceAPI.h"
#include "CMPComponentInterface.h"
#include "CMPData.h"

using namespace std;
CMPScienceAPI::CMPScienceAPI(CMPComponentInterface& componentinterface)
   : componentInterface(componentinterface){}

std::string CMPScienceAPI::name()
   {return componentInterface.getName();}
std::string CMPScienceAPI::FQName()
   {return componentInterface.getFQName();}
void CMPScienceAPI::write(const std::string& msg)
   {
   componentInterface.write(msg);
   }

void CMPScienceAPI::query(const std::string& pattern, std::vector<QueryMatch>& matches)
   {
   componentInterface.query(pattern, matches);
   }

// null
void CMPScienceAPI::subscribe(const std::string& name, boost::function0<void> handler)
   {componentInterface.subscribe(name, new CMPMethod0 (handler));}
void CMPScienceAPI::publish(const std::string& name)
   {
   Null dummy;
   componentInterface.publish(name, new CMPType<Null>(dummy));
   }

[foreach types.builtin]
// [builtin.cpptype]
bool CMPScienceAPI::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   IPackableData* temp = new CMPBuiltInBounded<[builtin.cpptype], [builtin.ctype] >(name, data, lower, upper);
   bool ok = componentInterface.read(name, temp, optional);
   [else]
   IPackableData* temp = new CMPBuiltIn<[builtin.cpptype] >(data);
   bool ok = componentInterface.read(name, temp, optional);
   [endif]
   delete temp;
   return ok;
   }
bool CMPScienceAPI::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   return componentInterface.get(name, units, optional, new CMPBuiltInBounded<[builtin.cpptype], [builtin.ctype] >(name, data, lower, upper));
   [else]
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype] >(data));
   [endif]
   }

void CMPScienceAPI::set(const std::string& name, const std::string& units, [builtin.cpptype]& data)
   {componentInterface.set(name, units, new CMPBuiltIn<[builtin.cpptype] >(data));}
void CMPScienceAPI::expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable)
   {componentInterface.expose(name, units, description, writable, new CMPBuiltIn<[builtin.cpptype] >(variable));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn)
   {componentInterface.expose(name, units, description, false, new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] >(fn, true));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                   boost::function1<void, [builtin.cpptype]&> getter,
                                   boost::function1<void, [builtin.cpptype]&> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (getter, setter));
   }
void CMPScienceAPI::subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler)
   {componentInterface.subscribe(name, new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (handler, false));}
void CMPScienceAPI::publish(const std::string& name, [builtin.cpptype]& data)
   {componentInterface.publish(name, new CMPBuiltIn<[builtin.cpptype] >(data));}

[endfor]

[endfile]
