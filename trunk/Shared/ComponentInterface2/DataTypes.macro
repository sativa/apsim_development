##################################################
[file DataTypes.h]
#ifndef DataTypesH
#define DataTypesH
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include <ComponentInterface2/MessageData.h>
#include <ComponentInterface2/Interfaces.h>

   //------ Null ------
   struct Null
      {
      int i;
      };

   inline void pack(MessageData& messageData, const Null& data)
      { }
   inline void unpack(MessageData& messageData, Null& data)
      { }
   inline unsigned memorySize(const Null& data)
      {return 0;}
   std::string DDML(const Null& data)
      {return "<type/>";}


[foreach types.type]
   //------ [type.name] ------
   struct [type.name]
      {
      [foreach type.field]
      [field.ctype] [field.name];
      [endfor]
      };

   inline void pack(MessageData& messageData, const [type.name]& data)
      {
      [foreach type.field]
      pack(messageData, data.[field.name]);
      [endfor]
      }
   inline void unpack(MessageData& messageData, [type.name]& data)
      {
      [foreach type.field]
      unpack(messageData, data.[field.name]);
      [endfor]
      }
   inline unsigned memorySize(const [type.name]& data)
      {
      return 0
       [foreach type.field]              + ::memorySize(data.[field.name])
       [endfor]              ;
      }
   std::string DDML(const [type.name]& data)
      {return [type.cddml];}

[endfor]
#endif
[endfile]

##################################################
[file ScienceAPI.h]
#ifndef ScienceAPIH
#define ScienceAPIH
#include <general/platform.h>
#include <string>
#include <vector>
#include <boost/function.hpp>
#include <boost/bind.hpp>

struct QueryMatch
   {
   std::string name;
   std::string units;
   };

// ------------------------------------------------------------------
// Interface for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class ScienceAPI
   {
   public:

      virtual void write(const std::string& msg) = 0;
      virtual std::string name() = 0;
      virtual std::string parent() = 0;

      // -----------------------------------------------------------------------
      // Return a list of all variables or components (fully qualified)
      // that match the specified pattern.
      // e.g. * will return a list of all components.
      //      wheat.* will return a list of all variables for the wheat module
      //      *.lai will return a list of all lai variables for all modules.
      // -----------------------------------------------------------------------
      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;

      // null
      #define nullFunction(address) boost::function0<void>(boost::bind(address, this))
      virtual void subscribe(const std::string& name, boost::function0<void> handler) = 0;
      virtual void publish(const std::string& name) = 0;

      [foreach types.builtin]
      // [builtin.ctype]
      #define [builtin.name]Function(address) boost::function1<void, [builtin.ctype]& >(boost::bind(address, this, _1))
      virtual bool read(const std::string& name, [builtin.ctype]& data, bool optional) = 0;
      virtual void get(const std::string& name, const std::string& units, bool optional, [builtin.ctype]& data) = 0;
      virtual void set(const std::string& name, const std::string& units, [builtin.ctype]& data) = 0;
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.ctype]& variable) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.ctype]&> fn) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.ctype]&> getter,
                                  boost::function1<void, [builtin.ctype]&> setter) = 0;
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.ctype]&> handler) = 0;
      virtual void publish(const std::string& name, [builtin.ctype]& data) = 0;

      [endfor]
   };
#endif
[endfile]

##################################################
[file CMPScienceAPI.h]
#ifndef CMPScienceAPIH
#define CMPScienceAPIH
#include <ComponentInterface2/ScienceAPI.h>
class CMPComponentInterface;

// ------------------------------------------------------------------
// CMP Implementation for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class CMPScienceAPI : public ScienceAPI
   {
   public:
      CMPScienceAPI(CMPComponentInterface& componentinterface);

      virtual void write(const std::string& msg);
      virtual std::string name();
      virtual std::string parent();

      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches);

      // null
      virtual void subscribe(const std::string& name, boost::function0<void> handler);
      virtual void publish(const std::string& name);

      [foreach types.builtin]
      // [builtin.ctype]
      virtual bool read(const std::string& name, [builtin.ctype]& data, bool optional);
      virtual void get(const std::string& name, const std::string& units, bool optional, [builtin.ctype]& data);
      virtual void set(const std::string& name, const std::string& units, [builtin.ctype]& data);
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.ctype]& variable);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.ctype]&> method);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                  boost::function1<void, [builtin.ctype]&> getter,
                                  boost::function1<void, [builtin.ctype]&> setter);
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.ctype]&> handler);
      virtual void publish(const std::string& name, [builtin.ctype]& data);

      [endfor]

   private:
      CMPComponentInterface& componentInterface;
   };
#endif
[endfile]


##################################################
[file CMPScienceAPI.cpp]
#pragma hdrstop

#include "CMPScienceAPI.h"
#include "CMPComponentInterface.h"
#include "CMPData.h"

using namespace std;
CMPScienceAPI::CMPScienceAPI(CMPComponentInterface& componentinterface)
   : componentInterface(componentinterface){}

std::string CMPScienceAPI::name()
   {return componentInterface.getName();}
std::string CMPScienceAPI::parent()
   {return componentInterface.getParentName();}
void CMPScienceAPI::write(const std::string& msg)
   {
   componentInterface.write(msg);
   }

void CMPScienceAPI::query(const std::string& pattern, std::vector<QueryMatch>& matches)
   {
   componentInterface.query(pattern, matches);
   }

// null
void CMPScienceAPI::subscribe(const std::string& name, boost::function0<void> handler)
   {componentInterface.subscribe(name, new CMPMethod0 (handler));}
void CMPScienceAPI::publish(const std::string& name)
   {
   Null dummy;
   componentInterface.publish(name, new CMPType<Null>(dummy));
   }

[foreach types.builtin]
// [builtin.ctype]
bool CMPScienceAPI::read(const std::string& name, [builtin.ctype]& data, bool optional)
   {return componentInterface.read(name, CMPBuiltIn<[builtin.ctype] >(data), optional);}
void CMPScienceAPI::get(const std::string& name, const std::string& units, bool optional, [builtin.ctype]& data)
   {return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.ctype] >(data));}

void CMPScienceAPI::set(const std::string& name, const std::string& units, [builtin.ctype]& data)
   {componentInterface.set(name, units, new CMPBuiltIn<[builtin.ctype] >(data));}
void CMPScienceAPI::expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.ctype]& variable)
   {componentInterface.expose(name, units, description, writable, new CMPBuiltIn<[builtin.ctype] >(variable));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.ctype]&> fn)
   {componentInterface.expose(name, units, description, false, new CMPMethod1<boost::function1<void, [builtin.ctype]&>, [builtin.ctype] >(fn, true));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                   boost::function1<void, [builtin.ctype]&> getter,
                                   boost::function1<void, [builtin.ctype]&> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new CMPMethod1<boost::function1<void, [builtin.ctype]&>, [builtin.ctype] > (getter, setter));
   }
void CMPScienceAPI::subscribe(const std::string& name, boost::function1<void, [builtin.ctype]&> handler)
   {componentInterface.subscribe(name, new CMPMethod1<boost::function1<void, [builtin.ctype]&>, [builtin.ctype] > (handler, false));}
void CMPScienceAPI::publish(const std::string& name, [builtin.ctype]& data)
   {componentInterface.publish(name, new CMPBuiltIn<[builtin.ctype] >(data));}

[endfor]

[endfile]
