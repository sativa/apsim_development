##################################################
#file ../Shared/ComponentInterface/datatypes.h
#ifndef DataTypesH
#define DataTypesH
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>

#include <ComponentInterface/MessageData.h>
#include <ComponentInterface/MessageDataExt.h>
#include <ComponentInterface/Type.h>
#include <ComponentInterface/Interfaces.h>

// Maximum Array Size for fortran arrays
#define max_array_size 100

namespace protocol {

//-------------------- Built in types
#define nullTypeDDML "<type/>"
#for_each type

#if (type.Array = T)
   std::string EXPORT DDML(const std::vector<type.ckind>& value);
#else
   std::string EXPORT DDML(const type.ckind& value);
#endif

#endfor

#for_each structure
//-------------------- structure.nameType
struct structure.nameType
   {
   #for_each structure.field
   #if (field.isArrayAndStructure = T)
   std::vector<field.ctypeType> field.name;
   #elseif (field.array = T)
   std::vector<field.ctype> field.name;
   #elseif (field.isStructure = T)
   field.ctypeType field.name;
   #else
   field.ctype field.name;
   #endif
   #endfor
   };
struct Fstructure.nameType
   {
   #for_each structure.field
   #if (field.isArrayAndStructure = T)
   Ffield.ctypeType field.name[max_array_size];
   #elseif (field.array = T)
   field.ctype field.name[max_array_size];
   #elseif (field.isStructure = T)
   Ffield.ctypeType field.name;
   #elseif (field.ctype = std::string)
   char field.name[max_array_size];
   #else
   field.ctype field.name;
   #endif
   #if (field.array = T)
   unsigned num_field.name;
   #endif
   #endfor
   };
inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const structure.nameType& data)
   {
   #for_each structure.field
   messageData << data.field.name;
   #endfor
   return messageData;
   }
inline protocol::MessageData& operator>>(protocol::MessageData& messageData, structure.nameType& data)
   {
   #for_each structure.field
   messageData >> data.field.name;
   #endfor
   return messageData;
   }
#if (structure.Array = T)
std::string EXPORT DDML(const std::vector<structure.nameType>& value);
#else
std::string EXPORT DDML(const structure.nameType& value);
#endif
inline unsigned int memorySize(const structure.nameType& data)
   {
   return 0
   #for_each structure.field
      + protocol::memorySize(data.field.name)
   #endfor;
   }
inline unsigned int memorySize(const Fstructure.nameType& data)
   {
   unsigned size = 0;
   #for_each structure.field
      #if (field.array = T)
      size += 4;
      for (unsigned i = 0; i != data.num_field.name; i++)
         size += protocol::memorySize(data.field.name[i]);
      #elseif (field.ctype = std::string)
      size += protocol::memorySize(FString(data.field.name, max_array_size, FORString));
      #else
      size += protocol::memorySize(data.field.name);
      #endif
   #endfor;
   return size;
   }
void Initstructure.name(structure.nameType& data, const std::string& xml);
#if (structure.array = T)
void Initstructure.name(std::vector<structure.nameType>& values, const std::string& xml);
#endif

#endfor
} // protocol
#endif

#endfile
##################################################
#file ../Shared/ComponentInterface/datatypes.cpp
#include <boost/lexical_cast.hpp>
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include <general/platform.h>

#include "Messages.h"
#include "datatypes.h"
#include "Component.h"

namespace protocol {
#for_each type
#if (type.Array = T)
std::string EXPORT DDML(const std::vector<type.ckind>& value)
#else
std::string EXPORT DDML(const type.ckind& value)
#endif
   {
   return type.cddml;
   }
#endfor
} // protocol

#for_each structure
namespace protocol {
void Initstructure.name(structure.nameType& data, const std::string& xml)
   {
   XMLDocument doc(xml, XMLDocument::xmlContents);
   XMLNode::iterator childI = doc.documentElement();
   #for_each structure.field
   childI = std::find_if(doc.documentElement().begin(),
                         doc.documentElement().end(),
                         EqualToName<XMLNode>("field.name"));

   #if (field.isArrayAndStructure = T)
   // Don't know yet
   #elseif (field.array = T)
   StringToContainer<std::vector<field.ctype>, field.ctype> (childI->getValue(), data.field.name);

   #elseif (field.isStructure = T)
   // Don't know yet
   #else
   data.field.name = boost::lexical_cast<field.ctype> (childI->getValue());
   #endif
   #endfor
   }
   #if (structure.array = T)
void Initstructure.name(std::vector<structure.nameType>& values, const std::string& xml)
   {
   XMLDocument doc(xml, XMLDocument::xmlContents);
   for (XMLNode::iterator childI = doc.documentElement().begin();
                          childI != doc.documentElement().end();
                          childI++)
      {
      string childXml = childI->write();
      structure.nameType data;
      Initstructure.name(data, childXml);
      values.push_back(data);
      }
   }
   #endif

#if (structure.Array = T)
std::string EXPORT DDML(const std::vector<structure.nameType>& value)
#else
std::string EXPORT DDML(const structure.nameType& value)
#endif
   {
   return structure.cddml;
   }
}; // namespace protocol
#endfor
#endfile
##################################################
#file ../apsim/infra/source/datatypes.f90
module dataTypes
   integer, parameter :: max_array_size = 100

   !-------------------- Built in types
   character(len=*), parameter :: nullTypeDDML = '<type/>'
#for_each type
   character(len=*), parameter :: type.nameTypeDDML = &
type.forddml
#endfor


#for_each structure
!-------------------- structure.nameType
   character(len=*), parameter :: structure.nameTypeDDML = &
structure.forddml
   type structure.nameType
      sequence
      #for_each structure.field
      #if (field.isArrayAndStructure = T)
      type(field.forTypeType):: field.name(max_array_size)
      #elseif (field.isStructure = T)
      type(field.forTypeType) :: field.name
      #elseif (field.array = T)
      field.fortype :: field.name(max_array_size)
      #else
      field.fortype :: field.name
      #endif
      #if (field.array = T)
      integer :: num_field.name
      #endif
      #endfor
   end type structure.nameType

#endfor
end module dataTypes
#endfile
##################################################
#file ../Shared/ComponentInterface/FORTRANdatatypes.cpp
#include <boost/lexical_cast.hpp>
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include <general/platform.h>

#include "Messages.h"
#include "datatypes.h"
#include "Component.h"
#include "FORTRANComponentWrapper.h"

extern "C" void EXPORT STDCALL publish_null(unsigned* id)
   {
   protocol::NoData pd;
   FortranWrapper::currentInstance->publish(*id, pd);
   }
#for_each structure
namespace protocol {
   inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const Fstructure.nameType& data)
      {
      #for_each structure.field
      #if (field.array = T)
      messageData << data.num_field.name;
      for (unsigned i = 0; i != data.num_field.name; i++)
         messageData << data.field.name[i];
      #elseif (field.ctype = std::string)
      messageData << FString(data.field.name, max_array_size, FORString);
      #else
      messageData << data.field.name;
      #endif
      #endfor
      return messageData;
      }
   inline protocol::MessageData& operator>>(protocol::MessageData& messageData, Fstructure.nameType& data)
      {
      #for_each structure.field
      #if (field.array = T)
      messageData >> data.num_field.name;
      for (unsigned i = 0; i != data.num_field.name; i++)
         messageData >> data.field.name[i];
      #elseif (field.ctype = std::string)
      FString field.nameString(data.field.name, max_array_size, FORString);
      FString field.nameAlias;
      messageData >> field.nameAlias;
      field.nameString = field.nameAlias;
      #else
      messageData >> data.field.name;
      #endif
      #endfor
      return messageData;
      }
}
   #if (structure.array = T)
extern "C" void EXPORT STDCALL publish_structure.name(unsigned* id, const protocol::Fstructure.nameType data[], unsigned* numValues)
   {
   FortranWrapper::currentInstance->publishArray(*id, data, *numValues);
   }
   #else
extern "C" void EXPORT STDCALL publish_structure.name(unsigned* id, const protocol::Fstructure.nameType* data)
   {
   FortranWrapper::currentInstance->publish(*id, *data);
   }
   #endif
   #if (structure.array = T)
extern "C" void EXPORT STDCALL unpack_structure.name(protocol::Variant* variant, protocol::Fstructure.nameType data[], unsigned* numValues)
   {
   variant->unpackArray(data, *numValues);
   }
   #else
extern "C" void EXPORT STDCALL unpack_structure.name(protocol::Variant* variant, protocol::Fstructure.nameType* data)
   {
   variant->unpack(*data);
   }
   #endif
#endfor

#endfile
##################################################
#file ../apsim/infra/source/datatypes.f90
module dataTypes
   integer, parameter :: max_array_size = 100

   !-------------------- Built in types
   character(len=*), parameter :: nullTypeDDML = '<type/>'
#for_each type
   character(len=*), parameter :: type.nameTypeDDML = &
type.forddml
#endfor


#for_each structure
!-------------------- structure.nameType
   character(len=*), parameter :: structure.nameTypeDDML = &
structure.forddml
   type structure.nameType
      sequence
      #for_each structure.field
      #if (field.isArrayAndStructure = T)
      type(field.forTypeType):: field.name(max_array_size)
      #elseif (field.isStructure = T)
      type(field.forTypeType) :: field.name
      #elseif (field.array = T)
      field.fortype :: field.name(max_array_size)
      #else
      field.fortype :: field.name
      #endif
      #if (field.array = T)
      integer :: num_field.name
      #endif
      #endfor
   end type structure.nameType

#endfor
end module dataTypes
#endfile


##################################################
#file ../apsim/infra/source/datatypesinterface.f90
module dataTypesInterface
   interface

   subroutine publish_null(id)
   use datatypes
   ml_external publish_null
   integer :: id
   end subroutine

   #for_each structure
   #if (structure.array = T)
   subroutine publish_structure.name(id, data, numValues)
   use datatypes
   ml_external publish_structure.name
   integer :: id
   type(structure.nameType) :: data(*)
   integer :: numValues
   end subroutine
   #else
   subroutine publish_structure.name(id, data)
   use datatypes
   ml_external publish_structure.name
   integer :: id
   type(structure.nameType) :: data
   end subroutine
   #endif

   #if (structure.array = T)
   subroutine unpack_structure.name(variant, data, numValues)
   use datatypes
   ml_external unpack_structure.name
   integer :: variant
   type(structure.nameType) :: data(*)
   integer :: numValues
   end subroutine
   #else
   subroutine unpack_structure.name(variant, data)
   use datatypes
   ml_external unpack_structure.name
   integer :: variant
   type(structure.nameType) :: data
   end subroutine
   #endif
   #endfor

   end interface
end module dataTypesInterface

#endfile
##################################################
#file ../apsim/tcllink/lib/apsimDatatypes.tcl
;# Automatically generated - do not edit

proc unpack_MessageData {data} {
   binary scan $data ii result(id) result(publishedByID)  ;# id, publishedByID
   set data [string range $data 8 end]

   binary scan $data i nchar                              ;# typeXML
   if {$nchar > 0} {
     set result(typeXML) [string range $data 4 [expr 4+$nchar-1]]
     set data [string range $data [expr 4+$nchar] end]
   }

   set ok [expr [string bytelength $data] > 0]
   while {$ok} {
      binary scan $data i nchar
      if {$nchar > 0} {
         ;##//messageData << variableName << protocol::memorySize(value)+5 << typeCode << isArray << value;
         set name [string range $data 4 [expr 4+$nchar-1]]         ;# Name
         set data [string range $data [expr 4+$nchar] end]
         binary scan $data iic nchar5 typeCode isArray             ;# type & array flag
         set data [string range $data 9 end]
         if {$typeCode == 8} {
            binary scan $data i nchar                              ;# string value
            set value [string range $data 4 [expr 4+$nchar-1]]
            set data [string range $data [expr 4+$nchar] end]
         } elseif {$typeCode == 2} {
            binary scan $data i value                              ;# integer
            set data [string range $data 4 end]
         } elseif {$typeCode == 4} {
            binary scan $data f value                              ;# float
            set data [string range $data 4 end]
         } elseif {$typeCode == 5} {
            binary scan $data d value                              ;# double
            set data [string range $data 8 end]
         } else {
            ;#set value "<undef>"
            error "Unhandled variant typecode $typeCode"
         }
         set result($name) $value
         set ok [expr [string bytelength $data] > 0]
      } else {
         set ok 0
      }
   }
   return [array get result]
}

#for_each structure
proc unpack_structure.name {data} {
#for_each structure.field
#if (field.array = T)
   binary scan $data i n ; set data [string range $data 4 end]
   for {set i 0} {$i < $n} {incr i} {
      set idx ".$i"
#else
      set idx ""
#endif
 #if (field.ctype = double)
     binary scan $data d result(field.name$idx); set data [string range $data 8 end]
 #elseif (field.ctype = bool)
     binary scan $data i result(field.name$idx); set data [string range $data 4 end]
 #elseif (field.ctype = int)
     binary scan $data i result(field.name$idx); set data [string range $data 4 end]
 #elseif (field.ctype = float)
     binary scan $data f result(field.name$idx); set data [string range $data 4 end]
 #elseif (field.ctype = std::string)
     binary scan $data i stringlength ; set data [string range $data 4 end]
     binary scan $data a$stringlength result(field.name$idx) ; set data [string range $data $stringlength end]
 #else
     array set result [process_ddml structure.cddml $data]
 #endif
#if (field.array = T)
   }
#endif
#endfor
   if {[string bytelength $data] != 0 && [info exists result(ddml)]} {
      array set result [process_ddml $result(ddml) $data]
   }
   return [array get result]
}
#endfor

package require tdom
proc process_ddml {ddml chunk} {
   set doc [dom parse $ddml]
   set docroot [$doc documentElement]
   array set result [list data $chunk]
   if {[catch {array set result [process_node $docroot $result(data)]} msg]} {
      lappend result(emsg) "Error:$msg"
      puts "Error:$msg"
   }
   if {[string bytelength $result(data)] > 0} {
      lappend result(emsg) "NB. unread data ([string bytelength $result(data)] bytes)"
   }
   return [array get result]
}

proc process_node {node chunk} {
   array set result [list data $chunk]
   if {[$node hasAttribute "name"]} {set name [$node getAttribute "name"]} else {set name "<anonymous>"}
   if {[$node hasAttribute "array"] && [$node getAttribute "array"] == "T"} {
     # Array types
     if {[$node hasAttribute "kind"]} {
        set kind [$node getAttribute "kind"]
        if {[binary scan $result(data) i n] == 1} {
           set result(data) [string range $result(data) 4 end]
        } else {
           set n 0
        }
        if {$kind == "double"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) d x]==1} {lappend arr $x; set result(data) [string range $result(data) 8 end]} else {error "error reading array double"}
          }  
          lappend result($name) $arr
        } elseif {$kind == "boolean"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading array bool"}
          }
          lappend result($name) $arr
        } elseif {$kind == "integer4"} {
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading arrray int"}
          }   
          lappend result($name) $arr
        } elseif {$kind == "single"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) f x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading array float (at $i of $n)"}
          }   
          lappend result($name) $arr
        } elseif {$kind == "string"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i stringlength] ==  1} {
                set result(data) [string range $result(data) 4 end]
                if {[binary scan $result(data) a$stringlength x]==1} {lappend arr $x; set result(data) [string range $result(data) $stringlength end]} else {error "error reading array string of $stringlength bytes"}
             } 
          }  
          lappend result($name) $arr
        } else {
          error "unimplemented array type kind=$kind"
        }
     } else {
        # an array of structures of some sort. Should probably do this $n times
        foreach child [$node childNodes] {
           array set result [process_node $child $result(data)]
        }
     }
  } else {
     if {[$node hasAttribute "kind"]} {
        set kind [$node getAttribute "kind"]
        # Scalar types
        if {$kind == "double"} {
          if {[binary scan $result(data) d x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 8 end]} else {error "error reading scalar double"}
        } elseif {$kind == "boolean"} {
          if {[binary scan $result(data) i x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar bool"}
        } elseif {$kind == "integer4"} {
          if {[binary scan $result(data) i x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar int"}
        } elseif {$kind == "single"} {
          if {[binary scan $result(data) f x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar float"}
        } elseif {$kind == "string"} {
          if {[binary scan $result(data) i stringlength]==1} {
             set result(data) [string range $result(data) 4 end]
             if {[binary scan $result(data) a$stringlength x]==1} {lappend result($name) $x; set result(data) [string range $result(data) $stringlength end]}  else {error "error reading scalar string ($stringlength bytes)"}
          } else {
             error "error reading scalar string length"
          }
        } else {
          error "unimplemented scalar type kind=$kind"
        }
     } else {
        # a structure of some sort
        foreach child [$node childNodes] {
           array set result [process_node $child $result(data)]
        }   
     }
   }
   return [array get result]
}

#endfile
