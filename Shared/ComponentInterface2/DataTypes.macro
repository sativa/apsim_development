##################################################
[file DataTypes.h]
#ifndef DataTypesH
#define DataTypesH
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include <ComponentInterface2/MessageData.h>
#include <ComponentInterface2/Interfaces.h>

   //------ Null ------
   struct Null
      {
      int i;
      };

   void pack(MessageData& messageData, const Null& data);
   void unpack(MessageData& messageData, Null& data);
   unsigned memorySize(const Null& data);
   std::string DDML(const Null& data);

[foreach types.type]
   //------ [type.name] ------
   struct [type.name]Type
      {
      [foreach type.field]
      [field.cpptype] [field.name];
      [endfor]
      };

   void pack(MessageData& messageData, const [type.name]Type& data);
   void unpack(MessageData& messageData, [type.name]Type& data);
   unsigned memorySize(const [type.name]Type& data);
   std::string DDML(const [type.name]Type& data);

[endfor]
   class Variant;
   void pack(MessageData& messageData, const Variant& data);
   void unpack(MessageData& messageData, Variant& data);
   unsigned memorySize(Variant& data) ;
   std::string DDML(const Variant& data);
#endif
[endfile]
##################################################
[file DataTypes.cpp]
#include <general/stl_functions.h>
#include <general/TreeNodeIterator.h>
#include <general/xml.h>
#include "DataTypes.h"
#include "MessageData.h"
#include "Interfaces.h"

   //------ Null ------
   void pack(MessageData& messageData, const Null& data) { }
   void unpack(MessageData& messageData, Null& data) { }
   unsigned memorySize(const Null& data) {return 0;}
   std::string DDML(const Null& data) {return "<type/>";}


[foreach types.type]
   //------ [type.name] ------

   void pack(MessageData& messageData, const [type.name]Type& data)
      {
      [foreach type.field]
      pack(messageData, data.[field.name]);
      [endfor]
      }
   void unpack(MessageData& messageData, [type.name]Type& data)
      {
      [foreach type.field]
      unpack(messageData, data.[field.name]);
      [endfor]
      }
   unsigned memorySize(const [type.name]Type& data)
      {
      return 0
       [foreach type.field]              + ::memorySize(data.[field.name])
       [endfor]              ;
      }
   std::string DDML(const [type.name]Type& data)
      {return [type.cddml];}

[endfor]
[endfile]

##################################################
[file ScienceAPI.h]
#ifndef ScienceAPIH
#define ScienceAPIH
#include <general/platform.h>
#include <string>
#include <vector>
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <ComponentInterface2/DataTypes.h>

// ------------------------------------------------------------------
// Interface for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

struct QueryMatch
   {
   std::string name;
   std::string ddml;
   };
class Variant;

class ScienceAPI
   {
   public:
      virtual ~ScienceAPI() {};
      
      virtual void write(const std::string& msg) = 0;
      virtual std::string name() = 0;
      virtual std::string FQName() = 0;

      // -----------------------------------------------------------------------
      // Return a list of all variables or components (fully qualified)
      // that match the specified pattern.
      // e.g. * will return a list of all components.
      //      wheat.* will return a list of all variables for the wheat module
      //      *.lai will return a list of all lai variables for all modules.
      // -----------------------------------------------------------------------
      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;

      // Methods for doing "search orders" when reading parameters: 
      virtual void setSearchOrder(const std::vector<std::string> &)=0;
      virtual void getSearchOrder(std::vector<std::string> &)=0;

      // Methods for reading raw strings
      virtual bool readRaw(const std::string& parName, std::vector<std::string> &values) = 0;

      // null
      #define nullFunction(address) boost::function0<void>(boost::bind(address, this))
      virtual void subscribe(const std::string& name, boost::function0<void> handler) = 0;
      virtual void publish(const std::string& name) = 0;

      [foreach types.builtin]
      // [builtin.cpptype]
      #define [builtin.name]Function(address) boost::function1<void, [builtin.cpptype]& >(boost::bind(address, this, _1))
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data) = 0;
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter) = 0;
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler) = 0;
      virtual void publish(const std::string& name, [builtin.cpptype]& data) = 0;

      [endfor]
      [foreach types.type]
      // [type.name]
      #define [type.name]Function(address) boost::function1<void, [type.name]Type& >(boost::bind(address, this, _1))
      virtual void subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler) = 0;
      virtual void publish(const std::string& name, [type.name]Type& data) = 0;

      [endfor]
      // Variant
      #define VariantFunction(address) boost::function1<void, Variant& >(bind(address, this, _1))
      virtual void subscribe(const std::string& name, boost::function1<void, Variant&> handler) = 0;
      virtual void publish(const std::string& name, Variant& data) = 0;
   };
#endif
[endfile]

##################################################
[file CMPScienceAPI.h]
#ifndef CMPScienceAPIH
#define CMPScienceAPIH
#include <general/platform.h>
#include <ComponentInterface2/ScienceAPI.h>

class CMPComponentInterface;
class Variant;
// ------------------------------------------------------------------
// CMP Implementation for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class EXPORT CMPScienceAPI : public ScienceAPI
   {
   private:
      CMPComponentInterface& componentInterface;

   public:
      CMPScienceAPI(CMPComponentInterface& componentinterface);
      virtual ~CMPScienceAPI() {};

      virtual void write(const std::string& msg);
      virtual std::string name();
      virtual std::string FQName();

      virtual void setSearchOrder(const std::vector<std::string> &list);
      virtual void getSearchOrder(std::vector<std::string> &list);

      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches);

      // Methods for reading raw strings
      virtual bool readRaw(const std::string& parName, std::vector<std::string> &values);

      // null
      virtual void subscribe(const std::string& name, boost::function0<void> handler);
      virtual void publish(const std::string& name);

      [foreach types.builtin]
      // [builtin.cpptype]
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data);
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> method);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                  boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter);
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler);
      virtual void publish(const std::string& name, [builtin.cpptype]& data);

      [endfor]
      [foreach types.type]
      virtual void subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler);
      virtual void publish(const std::string& name, [type.name]Type& data);

      [endfor]

      virtual void subscribe(const std::string& name, boost::function1<void, Variant&> handler);
      virtual void publish(const std::string& name, Variant& data);

   };
#endif
[endfile]


##################################################
[file CMPScienceAPI.cpp]
#include "CMPData.h"
#include "CMPComponentInterface.h"
#include "CMPScienceAPI.h"
#include "Variant.h"

using namespace std;
CMPScienceAPI::CMPScienceAPI(CMPComponentInterface& componentinterface)
   : componentInterface(componentinterface){}

string CMPScienceAPI::name()
   {return componentInterface.getName();}
string CMPScienceAPI::FQName()
   {return componentInterface.getFQName();}
void CMPScienceAPI::write(const string& msg)
   {
   componentInterface.write(msg);
   }

void CMPScienceAPI::query(const string& pattern, vector<QueryMatch>& matches)
   {
   componentInterface.query(pattern, matches);
   }

void CMPScienceAPI::setSearchOrder(const std::vector<string> &list) {componentInterface.setSearchOrder(list);};
void CMPScienceAPI::getSearchOrder(std::vector<string> &list) {componentInterface.getSearchOrder(list);};

bool CMPScienceAPI::readRaw(const string& parName, vector<string> &values)
   {return componentInterface.readRaw(parName, values);}

// null
void CMPScienceAPI::subscribe(const std::string& name, boost::function0<void> handler)
   {componentInterface.subscribe(name, new CMPMethod0 (handler));}
void CMPScienceAPI::publish(const std::string& name)
   {
   Null dummy;
   componentInterface.publish(name, new CMPType<Null>(dummy));
   }

[foreach types.builtin]
// [builtin.cpptype]
[if [builtin.boundable] = T]
bool CMPScienceAPI::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   IPackableData* temp = new CMPBuiltIn<[builtin.cpptype] >(data);
   bool ok = componentInterface.read(name, temp, optional);
   delete temp;
   return ok;
   }
[endif]
bool CMPScienceAPI::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   IPackableData* temp = new CMPBuiltInBounded<[builtin.cpptype], [builtin.ctype] >(name, data, lower, upper);
   bool ok = componentInterface.read(name, temp, optional);
   [else]
   IPackableData* temp = new CMPBuiltIn<[builtin.cpptype] >(data);
   bool ok = componentInterface.read(name, temp, optional);
   [endif]
   delete temp;
   return ok;
   }
[if [builtin.boundable] = T]
bool CMPScienceAPI::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype] >(data));
   }
[endif]
bool CMPScienceAPI::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   return componentInterface.get(name, units, optional, new CMPBuiltInBounded<[builtin.cpptype], [builtin.ctype] >(name, data, lower, upper));
   [else]
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype] >(data));
   [endif]
   }

void CMPScienceAPI::set(const std::string& name, const std::string& units, [builtin.cpptype]& data)
   {componentInterface.set(name, units, new CMPBuiltIn<[builtin.cpptype] >(data));}
void CMPScienceAPI::expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable)
   {componentInterface.expose(name, units, description, writable, new CMPBuiltIn<[builtin.cpptype] >(variable));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn)
   {componentInterface.expose(name, units, description, false, new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] >(fn, true));}
void CMPScienceAPI::exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                   boost::function1<void, [builtin.cpptype]&> getter,
                                   boost::function1<void, [builtin.cpptype]&> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (getter, setter));
   }
void CMPScienceAPI::subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler)
   {componentInterface.subscribe(name, new CMPMethod1<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (handler, false));}
void CMPScienceAPI::publish(const std::string& name, [builtin.cpptype]& data)
   {componentInterface.publish(name, new CMPBuiltIn<[builtin.cpptype] >(data));}

[endfor]
[foreach types.type]
void CMPScienceAPI::subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler)
     {componentInterface.subscribe(name, new CMPMethod1<boost::function1<void, [type.name]Type&>, [type.name]Type > (handler, false));}
void CMPScienceAPI::publish(const std::string& name, [type.name]Type& data)
     {componentInterface.publish(name, new CMPType< [type.name]Type >(data));}

[endfor]
void CMPScienceAPI::subscribe(const string& name, boost::function1<void, Variant&> handler)
     {componentInterface.subscribe(name, new CMPMethod1<boost::function1<void, Variant&>, Variant > (handler, false));}
void CMPScienceAPI::publish(const string& name, Variant& data)
     {componentInterface.publish(name, new CMPType< Variant >(data));}
[endfile]
