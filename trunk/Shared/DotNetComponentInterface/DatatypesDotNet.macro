##################################################
#file datatypes.h
#pragma once
#include "Message.h"
#include "MessageData.h"
#include "Interfaces.h"
#include "Utility.h"
#include <string>
using namespace System::Collections;
using namespace System::Reflection;

namespace ComponentInterface {
#for_each structure
//-------------------- structure.name type
#if (structure.array = T)
[DefaultMemberAttribute(S"value")]
#endif
public __gc class structure.name : public IManagedData #if (structure.array = T), public IEnumerable#endif

   {
   public:
      __delegate void EventHandler(structure.name* handler);
      EventHandler* handler;

      #if (structure.array = T)
      structure.name() : values(NULL) { }
      structure.name(int numElements) : values(new Type*[numElements]) { }
      __gc struct Type
         {
      #endif
         #for_each structure.field
         #if (field.ctype = std::string)
         String* field.name;
         #elseif (field.isStructure = T)
         field.ctype* field.name;
         #else
         field.ctype field.name;
         #endif
         #endfor
      #if (structure.array = T)
         };
      __property Type* get_value(int index) { return values[index]; }
      __property void set_value(int index, Type* value) { values[index] = value; }
      __property int get_Count() { return values->Count; }
      virtual IEnumerator* GetEnumerator() {return values->GetEnumerator();}

      #else
      structure.name() { }
      #endif

      void pack(Message& message)
         {
         #if (structure.array = T)
         ApsimInteger4(values->Count).pack(message);
         for (int i = 0; i != values->Count; i++)
            {
            #for_each structure.field
            #if (field.isStructure = T)
            values[i]->field.name->pack(message);
            #elseif (field.ctype <> char*)
            Apsimfield.KKind(values[i]->field.name).pack(message);
            #endif
            #endfor
            }
         #else
         #for_each structure.field
         #if (field.isStructure = T)
         field.name->pack(message);
         #elseif (field.ctype <> char*)
         Apsimfield.KKind(field.name).pack(message);
         #endif
         #endfor
         #endif
         }
      void unpack(Message& message)
         {
         #if (structure.array = T)
         int count = ApsimInteger4(message).value();
         values = new Type*[count];
         for (int i = 0; i != values->Count; i++)
            {
            values[i] = new Type;
            #for_each structure.field
            #if (field.isStructure = T)
            values[i]->field.name->unpack(message);
            #elseif (field.ctype <> char*)
            values[i]->field.name = Apsimfield.KKind(message).value();
            #endif
            #endfor
            }
         #else
         #for_each structure.field
         #if (field.isStructure = T)
         field.name = new ComponentInterface::field.ctype;
         field.name->unpack(message);
         #elseif (field.ctype <> char*)
         field.name = Apsimfield.KKind(message).value();
         #endif
         #endfor
         #endif
         }
      #if (structure.message <> T)
      const char* ddml()
         {
         return
structure.dotnetddml;
         }
   virtual void invokeEvent(Message& message)
      {
      handler(this);
      }

      #endif
   #if (structure.array = T)
   private:
      Type* values[];
   #endif
   };
#endfor
};
#endfile

##################################################
#file ApsimEvents.h
#pragma once
#include "datatypes.h"
#include "ComponentInterface.h"
#include "utility.h"

namespace ComponentInterface {
public  __gc class ApsimEvents
   {
   private:
      ComponentComms* comms;
   public:
      ApsimEvents(ComponentComms* _comms) : comms(_comms) { }

#for_each event
      // -----------------
      // event.name
      // -----------------
      void RegisterHandler(String* eventName, event.type::EventHandler* handler)
         {
         event.type* event = new event.type;
         event->handler = handler;
         IEventData* Data = new WrapManaged<event.type*>(event);
         comms->registerEventHandler(stringToStdString(eventName), Data);
         }

      // -----------------
      // event.name
      // -----------------
      void Publish(String* eventName, event.type* data)
         {
         IEventData* Data = new WrapManaged<event.type*>(data);
         comms->publishEvent(stringToStdString(eventName), Data);
         }

#endfor

   };
};
#endfile

##################################################
#file ApsimProperties.h
#pragma once
#include "datatypes.h"
#include "ComponentInterface.h"
#include "utility.h"
#include "messagedata.h"

namespace ComponentInterface {
#for_each type


public __gc class type.nameFunction : public IManagedData
   {
   private:
      Apsimtype.KKind* Dummy;

   public:
      __delegate type.dotnetkind Handler() type.dotnetarraybits;
      Handler* handler;
      type.nameFunction(){Dummy = new Apsimtype.KKind;}
      ~type.nameFunction() {delete Dummy;}
      void pack(Message& message)
         {
         Apsimtype.KKind(handler->Invoke()).pack(message);
         }
      const char* ddml()
         {
         return Dummy->ddml();
         }
      void unpack(Message& message) {throw new Exception("Cannot unpack a type.kindFunction");}
      virtual void invokeEvent(Message& message) {throw new Exception("Cannot unpack a calcFunction");}
   };
#endfor


public  __gc class ApsimProperties
   {
   private:
      ComponentComms* comms;
   public:
      __value enum ReadWriteType {Read=1, ReadWrite=2, Write=3};

      ApsimProperties(ComponentComms* _comms) : comms(_comms) { }

#for_each type
      void Get(String* PropertyName, type.dotnetkind (*Data) type.dotnetarraybits)
         {
         #if (type.array = T)
         ApsimArray<Apsimtype.KKind, type.dotnetkind> Value;
         #else
         Apsimtype.KKind Value;
         #endif
         comms->getProperty(stringToStdString(PropertyName), "", Value);
         *Data = Value.value();
         }
      bool Set(String* PropertyName, type.dotnetkind Data type.dotnetarraybits)
         {
         #if (type.array = T)
         ApsimArray<Apsimtype.KKind, type.dotnetkind> Value(Data);
         #else
         Apsimtype.KKind Value(Data);
         #endif
         return comms->setProperty(stringToStdString(PropertyName), "", Value);
         }
      #if (type.array = T)
      void Register(String* PropertyName, String* Units, ApsimProperties::ReadWriteType ReadWrite, type.dotnetkind (*Data) type.dotnetarraybits)
      #else
      void Register(String* PropertyName, String* Units, ApsimProperties::ReadWriteType ReadWrite, type.dotnetkind& Data type.dotnetarraybits)
      #endif
         {
         #if (type.array = T)
         WrapVariableAlias<ApsimArray<Apsimtype.KKind, type.dotnetkind>, type.dotnetkind type.dotnetarraybits>* wrapper = new WrapVariableAlias<ApsimArray<Apsimtype.KKind, type.dotnetkind>, type.dotnetkind type.dotnetarraybits>(*Data);
         #else
         WrapVariableAlias<Apsimtype.KKind, type.dotnetkind>* wrapper = new WrapVariableAlias<Apsimtype.KKind, type.dotnetkind>(Data);
         #endif
         comms->registerProperty(stringToStdString(PropertyName), stringToStdString(Units), ReadWrite, wrapper);
         }
      void RegisterHandler(String* PropertyName, String* Units, type.nameFunction::Handler* handler)
         {
         type.nameFunction* data = new type.nameFunction;
         data->handler = handler;
         IEventData* UnmanagedData = new WrapManaged<type.nameFunction*>(data);
         comms->registerProperty(stringToStdString(PropertyName), stringToStdString(Units), Read, UnmanagedData);
         }
#endfor

   };
};
#endfile
      